{-|
Module      : Tarefa1
Description : Task 1 - Pacman: generating /Mazes/
Copyright   : (c) Claudio Bessa, 2020
                  Ana Pires, 2020 
License     : GPL-3

= INTRODUCTION

In this Module we intended to create an incomplete starter /Maze/ generated by random numbers, surround it with walls and 
fill it with tunnels and put the /Ghosts'/ house at the center. At this part, the segment that consumed more time to make,
was to place the tunnels and the /Ghosts'/ house.

= STRATEGY

We started by creating functions that would provide us with random numbers, then we converted them to the type /Pieces/.
Next, we created lists made by /Pieces/, we changed them to /Corridors'/ and then finally to a /Maze/ (because a /Maze/, 
by default, is a listing of /Pieces'/ lists - /Corridors'/). The next step was to set the /Maze/ into a box. In other words, 
we're surrounding it with walls. To accomplish this, we had to create a function that generates /Corridors/ to fill the upper 
and lower bounds of the /Maze/. Then we preceded and proceeded each corridor with walls. Now, with every field filled, we 
need to create tunnels. To do so, we had to locate the middle of the /Maze's/ height and replace the walls (before and after 
the labyrinth in the coordinates found) with with the Empty  /Pieces/. Ultimately, to build the /Ghosts'/ house, we created 
the default house structure, for both conditions: whether the /Maze's/ length is either even or odd (if it is even, then the 
/Ghost's/ house length is 10; if it isn't, its length is 11) and placed it into the middle of the /Maze/. 
  
= CONCLUSION

As far as we are concerned, this task wasn't very difficult. Despite that , we believe to have done a great job, considering that all goals 
were accomplished and that the task at hand was easy to understand.

-}
{-# OPTIONS_HADDOCK prune #-}
module Tarefa1 where

import System.Random
import TypesandDatas

-- ** Generating random numbers

-- | Maze
maze = [
        [Wall, Wall, Wall, Wall, Wall, Wall, Wall, Wall],
        [Empty, Food Big, Food Little, Food Little, Food Little, Food Little, Food Little, Empty],
        [Empty, Food Little, Food Little, Food Little, Food Little, Wall, Food Little, Empty],
        [Wall, Wall, Wall, Wall, Wall, Wall, Wall, Wall]
       ]   

-- | Given a seed returns a list of n integer randomly generated; it takes the first n elements from an infinite series of random numbers between 0-99
generateRandoms :: Int -> Int -> [Int]
generateRandoms n seed = let gen = mkStdGen seed -- creates a random generator
                        in take n $ randomRs (0,99) gen 

-- | Given a seed returns an integer randomly generated
nrRandoms :: Int -> Int
nrRandoms seed = head $ generateRandoms 1 seed

-- | Converts a list into a list with size n
subList :: Int -> [a] -> [[a]]
subList _ [] = []
subList n l = take n l: subList n (drop n l)

-- ** Creating pieces and printing them

-- | Converts an integer number into a Piece
convertPiece :: Int -> Piece
convertPiece p 
        | p == 3 = Food Big
        | p >= 0 && p < 70 = Food Little
        | otherwise = Wall

-- | Converts a integers' list into a /Corridor/
convertCorridor :: [Int] -> Corridor
convertCorridor [] = []
convertCorridor (p:ps) = convertPiece p : convertCorridor ps

-- | Converts a /Corridor/ to a String
printCorridor :: Corridor -> String
printCorridor [] = []
printCorridor (p:ps) = show p ++ "" ++ printCorridor ps

-- | Converts a list of integers' lists into a /Maze/
convertMaze :: [[Int]] -> Maze
convertMaze [] = []
convertMaze (p:ps) = convertCorridor p : convertMaze ps

-- | Converts a /Maze/ to a String
printMazes :: Maze -> String
printMazes [] = []
printMazes (p:ps) = printCorridor p ++ "\n" ++ printMazes ps

-- ** Putting the /Maze/ into a box
-- | Creates a /Corridor/ of Walls
wallCorridor :: Int -> Corridor
wallCorridor x = replicate x Wall 

-- | Creates Walls in each /Corridor/
wallSides :: Maze -> Maze
wallSides [] = []
wallSides (x:xs) = (Wall : x ++ [Wall]) : wallSides xs

-- | Creates Walls all around the /Maze/
wallBox :: Maze -> Maze
wallBox maze = wallSides (p:maze ++ [p])
    where 
            p = wallCorridor (length (head maze))

-- | Get the middle of an Int
getMiddle :: Int -> Int
getMiddle x = div x 2

-- | Exchanges an index for a Piece
replaceinList :: Int -> Piece -> Corridor -> Corridor
replaceinList 0 p [] = []
replaceinList 0 p (x:xs) = p : xs
replaceinList n p (x:xs) = x : (replaceinList (n-1) p xs)

-- | Get the Walls after and before the /Maze/
replaceinCorridorAB :: Maze -> Int -> Piece -> Maze
replaceinCorridorAB  [] y t = []
replaceinCorridorAB (m:ms) 0 t = (replaceinList (length m-1) t (replaceinList 0 t m)) : ms
replaceinCorridorAB (m:ms) y t = m : replaceinCorridorAB ms (y-1) t

-- | Put Tunnels in the /Maze/
putTunnel :: Maze -> Maze
putTunnel x = 
            let middle = getMiddle (length x)
            in  if even (length x) == False 
                then replaceinCorridorAB x middle Empty
                else replaceinCorridorAB (replaceinCorridorAB x middle Empty) (middle - 1) Empty

-- ** Ghosts' house

-- | Creates the /Ghosts' House/ with specific measures: if the /Mazes's/ length is even, the Ghosts' House's length is 10, otherwise is 11 
buildHouse :: Maze -> Maze
buildHouse x 
        | even (length(head x)) = [[Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty],
                                  [Empty, Wall, Wall, Wall, Empty, Empty, Wall, Wall, Wall, Empty],
                                  [Empty, Wall, Empty, Empty, Empty, Empty, Empty, Empty, Wall, Empty],
                                  [Empty, Wall, Wall, Wall, Wall, Wall, Wall, Wall, Wall, Empty],
                                  [Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty]]

        | otherwise = [[Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty],
                      [Empty, Wall, Wall, Wall, Empty, Empty, Empty, Wall, Wall, Wall, Empty],
                      [Empty, Wall, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Wall, Empty],
                      [Empty, Wall, Wall, Wall, Wall, Wall, Wall, Wall, Wall, Wall, Empty],
                      [Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty, Empty]]

-- | Put the ghosts' pieces together
concatghosts :: Maze -> Maze -> Maze
concatghosts [] ghostss = []
concatghosts xs [] = []
concatghosts x ghosts = take a ghosts ++ getNotMiddle x (drop a ghosts) 
                    where a = (div ((length ghosts)-5) 2)

-- | Exchanges pieces for the /Ghosts' House/ does that for the first /Corridor/ of the /Ghosts' House/
replaceinCorridor :: Corridor -> Corridor -> Corridor
replaceinCorridor x l = take (div ((length l)-(length x)) 2) l 
                        ++ x 
                        ++ drop ((length x) + (div ((length l)-(length x)) 2) ) l

-- | Exchanges pieces for the /Ghosts' House/ does that for the rest of the /Corridors/ of the /Ghosts' House/
getNotMiddle :: Maze -> Maze -> Maze
getNotMiddle [] ghosts = ghosts 
getNotMiddle (x:xs) (g:gs) = [replaceinCorridor x g] ++ getNotMiddle xs gs

-- | Builds the /Ghosts' House/
ghostshouse :: Maze -> Maze
ghostshouse [] = []
ghostshouse l = concatghosts (buildHouse l) l   

-- ** Final functions
-- | Generates the /Maze/ randomly
genMazeR :: Int -> Int -> Int -> Maze
genMazeR x y s =
                 let random_nrs = generateRandoms (x*y) s
                 in convertMaze $ subList x random_nrs  

-- | Generates a valid /Maze/
genMaze :: Int -> Int -> Int -> Maze
genMaze width height seed = if width < 15 || height < 10 
                                 then error "Too Small need to be at least 15x10!!"                                 
                                 else ghostshouse  $ putTunnel
                                                   $ wallBox 
                                                   $ (genMazeR (width-2) (height-2) seed)

-- | Transforms Maze string into IO ()
generateMaze :: Maze -> IO ()
generateMaze maze = do putStrLn (printMazes maze)

-- ** Examples to test

-- | Example 1 genMazeR
maze1R :: Maze
maze1R = genMazeR 30 20 111111111111

-- | Example 2 genMazeR
maze2R :: Maze
maze2R = genMazeR 30 21 111111111111

-- | Example 1 wallBox
maze1w :: Maze
maze1w = wallBox (genMazeR 30 20 111111111111)

-- | Example 2 wallBox
maze2w :: Maze
maze2w = wallBox (genMazeR 30 21 111111111111)

-- | Example 1 putTunnel
maze1p :: Maze
maze1p = putTunnel (wallBox (genMazeR 30 20 111111111111))

-- | Example 2 putTunnel
maze2p :: Maze
maze2p = putTunnel (wallBox (genMazeR 30 21 111111111111))

-- | Example 1
maze1 :: Maze
maze1 = genMaze 30 20 111111111111

-- | Example 2
maze2 :: Maze
maze2 = genMaze 30 21 111111111111

